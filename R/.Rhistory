combo[[which.max(out[,1])]]
combo[[which.max(outw[,1])]]
j <- which.max(out[,1])
outj <- out[j, ]
mxu <- outj[1]
lou <- outj[2]
upu <- outj[3]
j <- which.max(outw[,1])
outj <- outw[j, ]
mxw <- outj[1]
low <- outj[2]
upw <- outj[3]
a1[k,l] <<- c(paste0(mxu, " (", lou,", ",upu, ") "))
a2[k,l] <<- c(paste0(mxw, " (", low,", ",upw, ") "))
cat(paste0(mxu, " (", lou,", ",upu, ") "), '\n')
cat(paste0(mxw, " (", low,", ",upw, ") "), '\n')
print(combo[[which.max(out[,1])]])
print(combo[[which.max(outw[,1])]])
# return(cbind(a1,a2))
}
optimalMatching(AA, AB, 1, 1)
optimalMatching(AA, AC, 1, 2)
optimalMatching(AA, AD, 1, 3)
optimalMatching(AA, AF, 1, 4)
optimalMatching(AA, AG, 1, 5)
optimalMatching(AB, AC, 2, 2)
optimalMatching(AB, AD, 2, 3)
optimalMatching(AB, AF, 2, 4)
optimalMatching(AB, AG, 2, 5)
optimalMatching(AC, AD, 3, 3)
optimalMatching(AC, AF, 3, 4)
optimalMatching(AC, AG, 3, 5)
optimalMatching(AD, AF, 4, 4)
optimalMatching(AD, AG, 4, 5)
optimalMatching(AF, AG, 5, 5)
a1
aa2
a2
bmiaf<- matrix(scan(text="
1215	33371	1725	0	0
3	12584	28636	4607	2
83	1683	4777	10587	6414
14	382	519	614	2369
12	253	368	437	848
"),5,5)
cohen.kappa(t(bmiaf))
cohen.kappa((bmiaf))
bmiaf
t(bmiaf)
cohen.kappa((bmiaf))
312	50171	68646	1736	1
319	1860	14097	23472	4635
47	859	3335	1943	539
172	437	679	917	2558
25	139	210	166	178
bmiaf<- matrix(scan(text="
312	50171	68646	1736	1
319	1860	14097	23472	4635
47	859	3335	1943	539
172	437	679	917	2558
25	139	210	166	178
"),5,5)
t(bmiaf)
cohen.kappa((bmiaf))
t(bmiaf)
cohen.kappa((bmiaf))
cohen.kappa((bmiaf))
bmiaf<- matrix(scan(text="
1215	33371	1725	0	0
3	12584	28636	4607	2
83	1683	4777	10587	6414
14	382	519	614	2369
12	253	368	437	848
"),5,5)
t(bmiaf)
cohen.kappa((bmiaf))
install.packages("TDA")
install.packages(c("backports", "bdsmatrix", "broom", "car", "checkmate", "chron", "coxme", "curl", "data.table", "devtools", "dfoptim", "digest", "eha", "foreach", "gamlss", "gamlss.dist", "git2r", "glue", "Hmisc", "hms", "htmlTable", "irlba", "iterators", "joineRML", "kimisc", "knitr", "lava", "lazyeval", "learnr", "lme4", "lubridate", "MASS", "Matrix", "mgcv", "multcomp", "officer", "openssl", "pcaPP", "purrr", "quantmod", "quantreg", "R.utils", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "reshape2", "rgl", "rlang", "rmarkdown", "rms", "robustbase", "rpart", "rprojroot", "rvg", "sp", "stringi", "tibble", "tidyr", "tidyselect", "tidyverse", "timeDate", "timeSeries", "viridis", "withr", "xts", "yaml", "zoo"))
devtools::install_github("rstudio/keras")
library(keras)
install_tensorflow()
library(keras)
install_tensorflow(gpu = T)
install.packages(c("haven", "Hmisc", "htmlTable", "htmlwidgets", "irlba", "joineRML", "ks", "mgcv", "pcaPP", "rgl", "rms", "sp"))
library(keras)
install_tensorflow(gpu = T)
install.packages("joineRML")
library(keras)
install_tensorflow(gpu = T)
install_tensorflow()
install.packages('devtools')
devtools::install_github("rstudio/keras")
devtools::install_github("rstudio/keras", force=TRUE)
library(keras)
install_tensorflow()
install_tensorflow(gpu=T)
?dataset_cifar10 #to see the help file for details of dataset
cifar<-dataset_cifar10()
install_keras()
install_tensorflow()
install_tensorflow(gpu=T)
library(keras)
install_tensorflow(gpu=T)
install_tensorflow()
devtools::install_github("rstudio/tensorflow")
library(tensorflow)
install_tensorflow()
library(survival)
rm(list=ls())
# Load in the subcohorts of Men and Women (Females)
# To obtain use
xM <- readRDS("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP/Data/D01 Men Wide format data (atleast four BMIs) 1570 cleaned with latent classes variable")
xF <- readRDS("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP/Data/D01 Women Wide format data (atleast four BMIs) 1570 cleaned with latent classes variable")
dim(xM);dim(xF)
## Remove 35 women and 2 men with inaccurate ORC diagnosis
xF <- xF[!xF$CANCER_SITE_NAMED %in% c("Prostate"), ]
xM <- xM[!xM$CANCER_SITE_NAMED %in% c("Ovary", "Corpus Uteri"), ]
dim(xM);dim(xF)
head(xM$BMI_cat_baseline)
dim(subset(xM, "G5_class"==1))
dim(subset(xM, G5_class==1))
dim(subset(xM, G5_class==5))
G5 <- subset(xM, G5_class==5)
G5$change18_35 <- G5$RF_BMI_35 - G5$RF_BMI_18
G5$change35_50 <- G5$RF_BMI_50 - G5$RF_BMI_35
G5$change50_65 <- G5$BMI_CUR - G5$RF_BMI_50
boxplot(G5$change18_35, G5$change35_50, G5$change50_65)
boxplot(G5$change18_35, G5$change35_50, G5$change50_65, xlab=c(12,42,2))
data <- cbind(G5$change18_35, G5$change35_50, G5$change50_65)
head(data)
data <- data.frame("18 to 35"=G5$change18_35, "18 to 35"=G5$change35_50, "18 to 35"=G5$change50_65)
head(data)
boxplot()
boxplot(data)
data <- data.frame("18to35"=G5$change18_35, "35to50"=G5$change35_50, "50to current"=G5$change50_65)
head(data)
boxplot(data, xlab=Age)
boxplot(data, xlab="Age")
boxplot(data, xlab="Age", ylab="Change in BMI")
boxplot(data, xlab="Age", ylab="Change in BMI", col=2)
boxplot(data, xlab="Age", ylab="Change in BMI", col="CadetBlue")
boxplot(data, xlab="Age", ylab="Change in BMI", col="CadetBlue", bty="n")
boxplot(data, xlab="Age", ylab="Change in BMI", col="CadetBlue", bty="\n")
boxplot(data, xlab="Age", ylab="Change in BMI", col="CadetBlue", bty='n')
length(G5$change50_65<=0)
length(G5$change35_50<=0)
length(G5$change50_65<=0)
sum(G5$change50_65<=0)
sum(G5$change35_50<=0)
sum(G5$change50_65<=0)
sum(G5$change18_35<=0);sum(G5$change35_50<=0);sum(G5$change50_65<=0)
n <- nrow(G5)
sum(G5$change18_35<=0);sum(G5$change35_50<=0);sum(G5$change50_65<=0)
round(sum(G5$change18_35<=0)/n*100,2);round(sum(G5$change35_50<=0)/n*100,2);round(sum(G5$change50_65<=0)/n*100,2)
round(sum(G5$change18_35<=-1)/n*100,2);round(sum(G5$change35_50<=-1)/n*100,2);round(sum(G5$change50_65<=-1)/n*100,2)
round(sum(G5$change18_35<=-2)/n*100,2);round(sum(G5$change35_50<=-2)/n*100,2);round(sum(G5$change50_65<=-2)/n*100,2)
round(sum(G5$change18_35<=0)/n*100,2);round(sum(G5$change35_50<=0)/n*100,2);round(sum(G5$change50_65<=0)/n*100,2)
round(sum(G5$change18_35<=-2)/n*100,2);round(sum(G5$change35_50<=-2)/n*100,2);round(sum(G5$change50_65<=-2)/n*100,2)
round(sum(G5$change18_35<=-5)/n*100,2);round(sum(G5$change35_50<=-5)/n*100,2);round(sum(G5$change50_65<=-5)/n*100,2)
n
G5 <- subset(xF, G5_class==5)
G5$change18_35 <- G5$RF_BMI_35 - G5$RF_BMI_18
G5$change35_50 <- G5$RF_BMI_50 - G5$RF_BMI_35
G5$change50_65 <- G5$BMI_CUR - G5$RF_BMI_50
n <- nrow(G5)
sum(G5$change18_35<=0);sum(G5$change35_50<=0);sum(G5$change50_65<=0)
round(sum(G5$change18_35<=0)/n*100,2);round(sum(G5$change35_50<=0)/n*100,2);round(sum(G5$change50_65<=0)/n*100,2)
round(sum(G5$change18_35<=-2)/n*100,2);round(sum(G5$change35_50<=-2)/n*100,2);round(sum(G5$change50_65<=-2)/n*100,2)
round(sum(G5$change18_35<=-5)/n*100,2);round(sum(G5$change35_50<=-5)/n*100,2);round(sum(G5$change50_65<=-5)/n*100,2)
n
dim(G5)
# Song mean BMI and s.e in each group
meanSE <- function(x, acc=2){
mx <- round(mean(x), acc);
sx <- round(sd(x)/sqrt(length(x)), acc)
return(paste0(mx," (",sx,")"))
}
rbind(by(x$BMI_CUR, x$G5_class, meanSE))
x<- xM
rbind(by(x$BMI_CUR, x$G5_class, meanSE))
rbind(by(x$RF_BMI_50, x$G5_class, meanSE))
rbind(by(x$RF_BMI_35, x$G5_class, meanSE))
rbind(by(x$RF_BMI_18, x$G5_class, meanSE))
a <- rbind(by(x$BMI_CUR, x$G5_class, meanSE))
a <- cbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a
a <- rbind(by(x$BMI_CUR, x$G5_class, meanSE))
a <- cbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a <- cbind(a, rbind(by(x$RF_BMI_35, x$G5_class, meanSE)))
a <- cbind(a, rbind(by(x$RF_BMI_18, x$G5_class, meanSE)))
a
t(a)
a <- cbind(by(x$BMI_CUR, x$G5_class, meanSE))
a <- rbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$RF_BMI_35, x$G5_class, meanSE)))
a <- rbind(by(x$BMI_CUR, x$G5_class, meanSE))
a
a <- rbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a
a <- rbind(by(x$BMI_CUR, x$G5_class, meanSE))
a <- rbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$RF_BMI_35, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$RF_BMI_18, x$G5_class, meanSE)))
a
a <- rbind(by(x$RF_BMI_18, x$G5_class, meanSE))
a <- rbind(a, rbind(by(x$RF_BMI_35, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$BMI_CUR, x$G5_class, meanSE)))
a
x<- xF
a <- rbind(by(x$RF_BMI_18, x$G5_class, meanSE))
a <- rbind(a, rbind(by(x$RF_BMI_35, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$RF_BMI_50, x$G5_class, meanSE)))
a <- rbind(a, rbind(by(x$BMI_CUR, x$G5_class, meanSE)))
a
# Include scenario D and E
setwd("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP")
# Load in the subcohorts of Men and Women (Females)
# To obtain use
xM <- readRDS("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP/Data/D01 Men Wide format data (atleast four BMIs) 1570 cleaned with latent classes variable")
xF <- readRDS("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP/Data/D01 Women Wide format data (atleast four BMIs) 1570 cleaned with latent classes variable")
dim(xM);dim(xF)
# Include scenario A and C, D
library(sas7bdat)
library(lcmm)
Am5 <- readRDS(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Mennonint/ofMen")
Af5 <- readRDS(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Womennonint/ofWomen")
Amx <- Am5[,c(1:5, 15)]
Afx <- Af5[,c(1:5, 15)]
head(Amx)
model <- list(NULL)
# Model D
M <- readRDS("~/Dropbox/00 - AARP Paper/AARP/Data/M_5_B5_1")
# Model D
M <- readRDS("~/Dropbox (The University of Manchester)/00 - AARP Paper/AARP/Data/M_5_B5_1")
head(M$pprob)
head(Am5)
K <- nrow(of)
os <- read.sas7bdat(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Mennonint/os.sas7bdat")
head(os)
M
exp(c(M$best[1:4], 0))/(sum(exp(c(M$best[1:4], 0))))
os$PI
os$PI/100
sum(os$PI/100)
exp(c(M$best[1:4], 0))/(sum(exp(c(M$best[1:4], 0))))
exp(c(M$best[1:4], 0))
(sum(exp(c(M$best[1:4], 0))))
names(M)
!exists(M$ns)
exists(M$ns)
exists(M$ns)
(M$ns)
(M$call)
class(M$call)
(class(M$call)=="call")
outputs <- matrix(0, nrow=5, ncol=K)
rownames(outputs) <- c("APPA", "OCC", "mismatch", "Entropy", "RelativeEntropy")
head(M$pprob)
model$pprob <- of[,c("ID", "GROUP", paste0("GRP",1:K,"PRB"))]
of <- readRDS(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Womennonint/ofWomen")
os <- read.sas7bdat(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Mennonint/os.sas7bdat")
model$pprob <- of[,c("ID", "GROUP", paste0("GRP",1:K,"PRB"))]
K <- nrow(of)
model <- list(NULL)
model$pprob <- of[,c("ID", "GROUP", paste0("GRP",1:K,"PRB"))]
head(model$pp)
c("ID", "GROUP", paste0("GRP",1:K,"PRB", sep=""))
K
K <- ncol(of)
K
K <- ncol(oe)
K <- ncol(os)
K
head(os)
head(of)
op <- read.sas7bdat(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Mennonint/op.sas7bdat")
oe <- read.sas7bdat(file="~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/02 - Outputs/5class new/Output/A/Mennonint/oe.sas7bdat")
head(op)
head(oe)
head(of)
head(os)
K <- nrow(os)
K
n <- nrow(of)
n
c("ID", "GROUP", paste0("GRP",1:K,"PRB", sep=""))
model$pprob <- of[,c("ID", "GROUP", paste0("GRP",1:K,"PRB", sep=""))]
colnames(model$pprob)
head(M$pprob)
colnames(model$pprob) <- c("ID", "class", paste0("prob",1:k, sep=""))
head(model$pprob)
K <- ncol(model$pprob)-2
K
paste0("prob",1:k, sep=""))
paste0("prob",1:k, sep="")
p <- model$pprob[,c(paste0("prob",1:k, sep=""))]
return(appa)
# Hello, world!
#
# This function computes the Average Posterior Probability Assignment (APPA)
# for a K latent class trajectory model.
#
#
# Some useful keyboard shortcuts for package authoring:
#
#   Build and Reload Package:  'Cmd + Shift + B'
#   Check Package:             'Cmd + Shift + E'
#   Test Package:              'Cmd + Shift + T'
APPA <- function(p) {
# determine class size
K <- ncol(p)
# determine class
group <- class_assignment(p)
# save vector for appa values
appa <- rep(NA, times=K)
# Compute average posterior probabilites
for(i in 1:K) { classp <- p[group==i, i]
if(length(classp)!=0) appa[i] <- mean(classp)
}
return(appa)
}
n <- nrow(model$pprob)
K <- ncol(model$pprob)-2
p <- model$pprob[,c(paste0("prob",1:k, sep=""))]
if(class(model$call)=="SAS"){
PI <- os$PI/100
}else{
PI <- exp(c(model$best[1:4], 0))/(sum(exp(c(model$best[1:4], 0))))}
outputs <- matrix(0, nrow=5, ncol=K)
rownames(outputs) <- c("APPA", "OCC", "mismatch", "Entropy", "RelativeEntropy")
outputs[1, ] <- APPA(p)
# Hello, world!
#
# This function computes the Average Posterior Probability Assignment (APPA)
# for a K latent class trajectory model.
#
#
# Some useful keyboard shortcuts for package authoring:
#
#   Build and Reload Package:  'Cmd + Shift + B'
#   Check Package:             'Cmd + Shift + E'
#   Test Package:              'Cmd + Shift + T'
class_assignment <- function(p) {
as.numeric(apply(p, 1, which.max))
}
APPA(p)
table(y$G5_class)/nrow(y)
y=M
table(y$G5_class)/nrow(y)
y=M$pprob
table(y$G5_class)/nrow(y)
exp(c(M$best[1:4], 0))/(sum(exp(c(M$best[1:4], 0))))
exp(c(M$best[1:4], 0))/(sum(exp(c(M$best[1:4], 0))))
exp(c(M$best[1:4], 0))/(sum(exp(c(M$best[1:4], 0))))
PI
(1-PI)
PI <- os$PI/100
v
PI
PI/(1-PI)
APPA(p)
occ <- numerator/denominator
numerator   <- appa/(1-appa)
denominator <- PI/(1-PI)
appa <- APPA(p)
numerator   <- appa/(1-appa)
denominator <- PI/(1-PI)
occ <- numerator/denominator
occ
# output
# The odds of correct classification is the ratio of the odds of classification
# based on the maximum posterior probablity classification rule and
# the estimated class membership proportions ($\pi_k$).
# input
# p is the average posterior probability assignment of length K
# PI is the estimated proportion of class membership of length K
OCC <- function(p, PI){
appa <- APPA(p)
numerator   <- appa/(1-appa)
denominator <- PI/(1-PI)
occ <- numerator/denominator
return(occ)
}
OCC(p, PI)
outputs[2, ] <- OCC(p, PI)
mismatch <- function(p, pi) {
# determine class
group <- class_assignment(p)
# Tabulate the actual proportions
actprop <- tabulate(group, nbins=K)/nrow(p)
# Compute the mismatch (mismatch=actual-estimated)
return(actprop - pi)
}
mismatch(p, PU)
mismatch(p, PI)
PI
outputs[3, ] <- mismatch(p, PI)
outputs
outputs[1, ] <- APPA(p)
outputs
top <- p[1:20,]
top
1 + (sum(top*log(top))/(nrow(y)*log(5)))
top <- p
1 + (sum(top*log(top))/(nrow(y)*log(5)))
K <- ncol(p)
n <- nrow(p)
top <- p
1 + (sum(p*log(p))/(n*log(K)))
# output
# The odds of correct classification is the ratio of the odds of classification
# based on the maximum posterior probablity classification rule and
# the estimated class membership proportions ($\pi_k$).
# input
# p is the average posterior probability assignment of length K
# PI is the estimated proportion of class membership of length K
Entropy <- function(p){
K <- ncol(p)
n <- nrow(p)
entropy <- 1 + (sum(p*log(p))/(n*log(K)))
return(Entropy)
}
p*log(p)
dim(p*log(p))
outputs[4, ] <- Entropy(p)
Entropy(p)
outputs[4, 1] <- Entropy(p)
outputs[5, 1] <- RelativeEntropy(p)
Entropy(p)
# output
# The odds of correct classification is the ratio of the odds of classification
# based on the maximum posterior probablity classification rule and
# the estimated class membership proportions ($\pi_k$).
# input
# p is the average posterior probability assignment of length K
# PI is the estimated proportion of class membership of length K
Entropy <- function(p){
entropy <- -1*sum(p*log(p))
return(Entropy)
}
# output
# The odds of correct classification is the ratio of the odds of classification
# based on the maximum posterior probablity classification rule and
# the estimated class membership proportions ($\pi_k$).
# input
# p is the average posterior probability assignment of length K
# PI is the estimated proportion of class membership of length K
Entropy <- function(p){
entropy <- -1*sum(p*log(p))
return(entropy)
}
outputs[4, 1] <- Entropy(p)
outputs[5, 1] <- RelativeEntropy(p)
RelativeEntropy <- function(p){
K <- ncol(p)
n <- nrow(p)
relEntropy <- 1 + (sum(p*log(p))/(n*log(K)))
return(relEntropy)
}
RelativeEntropy(p)
outputs[5, 1] <- RelativeEntropy(p)
outputs
outputs[4:5, 2:K] <- rep("Globalvalue")
outputs
outputs[4:5, 2:K] <- rep("NULL")
outputs
outputs[4:5, 2:K] <- rep(0)
outputs
outputs <- matrix(0, nrow=5, ncol=K)
rownames(outputs) <- c("APPA", "OCC", "mismatch", "Entropy", "RelativeEntropy")
outputs[1, ] <- APPA(p)
outputs[2, ] <- OCC(p, PI)
outputs[3, ] <- mismatch(p, PI)
outputs[4, 1] <- Entropy(p)
outputs[5, 1] <- RelativeEntropy(p)
outputs[4:5, 2:K] <- rep(0)
outputs
class(model)
model
LCTMtoolkit <- function(FittedModel, inputType){
if(inputType=="SAS"){
model <- SASmodelbuilder(model)
}
n <- nrow(model$pprob)
K <- ncol(model$pprob)-2
p <- model$pprob[,c(paste0("prob",1:k, sep=""))]
if(class(model$call)=="SAS"){
PI <- os$PI/100
}else{
PI <- exp(c(model$best[1:4], 0))/(sum(exp(c(model$best[1:4], 0))))}
outputs <- matrix(0, nrow=5, ncol=K)
rownames(outputs) <- c("APPA", "OCC", "mismatch", "Entropy", "RelativeEntropy")
outputs[1, ] <- APPA(p)
outputs[2, ] <- OCC(p, PI)
outputs[3, ] <- mismatch(p, PI)
outputs[4, 1] <- Entropy(p)
outputs[5, 1] <- RelativeEntropy(p)
outputs[4:5, 2:K] <- rep(0)
return(outputs)
}
class(M)
length(M)
install.packages("roxygen2")
roxygen2::roxygenise()
roxygen2::roxygenise(OCC.R)
roxygen2::roxygenise('OCC.R')
setwd("~/Dropbox (The University of Manchester)/02 - BMJ Open Paper")
setwd("~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/LCTMtools")
roxygen2::roxygenise('OCC.R')
setwd("~/Dropbox (The University of Manchester)/02 - BMJ Open Paper/LCTMtools/R")
roxygen2::roxygenise('OCC.R')
